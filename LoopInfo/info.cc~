#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstVisitor.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/Dominators.h"
#include "llvm/Analysis/DependenceAnalysis.h"
#include "llvm/Analysis/ScalarEvolution.h"
#include "llvm/Analysis/ScalarEvolutionExpressions.h"
#include "llvm/Analysis/LoopInfo.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/Transforms/Utils/CodeExtractor.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/FileUtilities.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Instruction.def"
#include <stdlib.h>
#include <iostream>
#include <map>
#include <set>
#include <unordered_set>
#include <cxxabi.h>
#define myassert(cond) \
        do { \
        if (!(cond)) \
        { \
            cerr<< "\nassertion failed ("<<#cond <<"), File \"" << __FILE__ <<"\", Function \""<<__func__<<"\", Line "<< __LINE__<<"\n\n"; \
            exit(1); \
        } \
        } while (0)
        
#define log(i) fd<<"num of "<<#i<<" insts = "<<instCnt[AddrSpaceCastInst::i]<<"\n";
#define instMax 128
#define binOp 127
#define BBSI 20 //basic block size interval

using namespace std;
using namespace llvm;


namespace {
struct myPass : FunctionPass, InstVisitor<myPass>
{
  Module *M = 0;
  DataLayout *DL = 0;
  static char ID;
  myPass() : FunctionPass(ID) {}

  //StringRef getPassName() const override {
  const char* getPassName() const override {
    return "IR info collect";
  }
  
  LLVMContext *C = 0;
  Type* int64Ty = 0;
  Type* int32Ty = 0;
  Type* boolTy = 0;
  Type* voidTy = 0;
  Type* boolPtrTy = 0;
  
  
  ScalarEvolution *SE;
  DependenceInfo *DI;
  LoopInfo *LI;
  DominatorTree *DT; 
  
  int instCnt[instMax];
  

  
  error_code EC;
  string fileName = "/home/hc475/compiler/workspace/info.txt";
  
  
 
	void getAnalysisUsage(AnalysisUsage &AU) const override {
		/*AU.addRequired<LoopInfoWrapperPass>();
		AU.addRequired<DominatorTreeWrapperPass>();
		AU.addRequired<ScalarEvolutionWrapperPass>();
		AU.addRequired<DependenceAnalysisWrapperPass>();*/
	}

	
  bool doInitialization(Module &Mod) override {
    M = &Mod;
    if (DL)
      delete DL;
    DL = new DataLayout(M);
    C = &(M->getContext());
    int32Ty = Type::getInt32Ty(*C);
    int64Ty = Type::getInt64Ty(*C);
    boolTy = Type::getInt1Ty(*C);
    voidTy = Type::getVoidTy(*C);
    boolPtrTy = Type::getInt1PtrTy(*C);

    return false;
  }
  
  
	//test if a value is a constant, return the value if yes, -1 otherwise
  int getConstant(Value *v)
  {
  	if(ConstantInt *c = dyn_cast<ConstantInt>(v)) 
  		return c->getValue().getLimitedValue();
  	else return -1;	
	}
	
	//get the return instruction of a function
	ReturnInst* getRetInst(Function* F)
	{
		if(F->doesNotReturn()) return nullptr;
		for(auto& bb:F->getBasicBlockList()){
			TerminatorInst* term = bb.getTerminator();
			if(!term) continue;
			if(ReturnInst* ret = dyn_cast<ReturnInst>(term)) return ret;
		}
		return nullptr;
	}
	
	
	int numInst(Function* F)
	{
		int sum = 0;
		for(auto& bb: *F)
			sum+=numInst(&bb);
		return sum;
	}
	
	int numInst(BasicBlock* B)
	{
		return B->size();
	}
	
	int floatCnt = 0;
	int intCnt=0;
	int floatVecCnt = 0;
	int intVecCnt = 0;
	
	void visitAllocaInst(AllocaInst &I) {
    instCnt[AddrSpaceCastInst::MemoryOps::Alloca]++;
  }
  
	void visitStoreInst(StoreInst &I) {
    instCnt[AddrSpaceCastInst::MemoryOps::Store]++;
  }
  
	void visitLoadInst(LoadInst &I) {
    instCnt[AddrSpaceCastInst::MemoryOps::Load]++;
  }
  
	void visitCallInst(CallInst &I) {
    instCnt[AddrSpaceCastInst::OtherOps::Call]++;
  }
  
  void visitBinaryOperator(BinaryOperator &I) {
    instCnt[binOp]++;
    Type* ty = I.getOperand(0)->getType();
    if(ty->isFloatingPointTy()) floatCnt++;
    else if(ty->isIntegerTy()) intCnt++;
    else if(ty->isVectorTy())
    {
    	Type* tys = ty->getScalarType();
    	if(tys->isFloatingPointTy()) floatVecCnt++;
  		else if(tys->isIntegerTy()) intVecCnt++;
    }
    else ty->dump();
  }

	int* basicBlockRange(Function &F)
	{
		int i = BBSI;
		int *res = (int*)calloc(100, sizeof(int));
		for(auto& bb: F)
			res[bb.size()/i]++;
			
		return res;
	}  
	
  bool runOnFunction(Function &F) override {
    /*SE = &getAnalysis<ScalarEvolutionWrapperPass>().getSE();
		DI = &getAnalysis<DependenceAnalysisWrapperPass>().getDI();
		DT = &getAnalysis<DominatorTreeWrapperPass>().getDomTree();
		LI = &getAnalysis<LoopInfoWrapperPass>().getLoopInfo();*/
		if(F.isIntrinsic()) return false;
    for(int i=0;i<instMax;i++)
    	instCnt[i]=0;
    	
		floatCnt = 0;
		intCnt=0;
		floatVecCnt = 0;
		intVecCnt = 0;
    	
		visit(F);
		cout<<"function: "<<F.getName().str()<<endl;
		int status;
		raw_fd_ostream fd(fileName, EC, sys::fs::F_Append);
		fd<<F.getName().str()<<"\n";
		
		const char* mn = F.getName().data();


		fd<<"num of args = "<<F.arg_size()<<"\n";
		fd<<"num of inst = "<<numInst(&F)<<"\n";
		
		log(MemoryOps::Alloca);
		log(MemoryOps::Store);
		log(MemoryOps::Load);
		log(OtherOps::Call);
		fd<<"num of binary op = "<<instCnt[binOp]<<"\n";
		fd<<"  floating point = "<<floatCnt<<"\n";
		fd<<"  floating point vector = "<<floatVecCnt<<"\n";
		fd<<"  integer = "<<intCnt<<"\n";
		fd<<"  integer vector = "<<intVecCnt<<"\n";
		
		int* bbr = basicBlockRange(F);
		fd<<"basic block sizes = \n";
		for(int i=0;i<100;i++)
			if(bbr[i]>0) fd<<i*BBSI<<"-"<<(i+1)*BBSI<<"\t\t\t\t\t\t\t\t\t\t"<<bbr[i]<<"\n";
    
    
    
    fd<<"\n\n";
    return false;
  }
};
char myPass::ID;


void addmyPass(const PassManagerBuilder &Builder, legacy::PassManagerBase &PM) {
  PM.add(new myPass());
}

/// Register the pass with the pass manager builder.  This instructs the
/// builder to call the `addSimplePass` function at the end of adding other
/// optimisations, so that we can insert the pass.  See the
/// `PassManagerBuilder` documentation for other extension points.
RegisterStandardPasses X(PassManagerBuilder::EP_OptimizerLast,
                         addmyPass);
} // anonymous namespace


